const fp = require('fastify-plugin')
const FJS = require('fast-json-stringify')
const ms = require('ms')

const LocalStore = require('./store/LocalStore')
const RedisStore = require('./store/RedisStore')

const serializeError = FJS({
  type: 'object',
  properties: {
    statusCode: { type: 'number' },
    error: { type: 'string' },
    message: { type: 'string' }
  }
})

/**
 *
 * @param fastify
 * @param settings
 * @param next
 *
 *
 * *** settings object can have the following key :
 * - 'global'           : will tell to the plugin if all route will be set will a `rate limit`
 * - 'appName'          : use only if the plugin is using Redis. The `appName` will be use a prefix for the keys
 * - 'max'              : is the maximum number of requests a single client can perform inside a timeWindow.
 * - 'timeWindow'       : the duration of the time window, can be expressed in milliseconds (as a number) or as a string, see [`ms`](https://github.com/zeit/ms) too see the supported formats.
 * - 'cache'            : this plugin internally uses a lru cache to handle the clients, you can change the size of the cache with this option.
 * - 'whitelist'        : array of string of ips to exclude from rate limiting.
 * - 'redis'            : by default this plugins uses an in-memory store, which is fast but if you application works on more than one server it is useless, since the data is store locally.<br>
 *                       You can pass a Redis client here and magically the issue is solved. To achieve the maximum speed, this plugins requires the use of [`ioredis`](https://github.com/luin/ioredis).
 * - 'whiteListInRedis' : will store the `whitelist` in Redis. The check will be done in redis too. This can provide an easy way for the admin to inject new value in the `whitelist`.
 * - 'skipOnError'      : if `true` it will skip errors generated by the storage (eg, redis not reachable).
 * - 'keyGenerator'     : a function to generate a unique identifier for each incoming request. Defaults to `(req) => req.ip`, the IP is resolved by fastify using `req.connection.remoteAddress` or `req.headers['x-forwarded-for']` if [trustProxy](https://www.fastify.io/docs/master/Server/#trustproxy) option is enabled. Use it if you want to override this behavior. Example usage:
 *
 *
 */

function rateLimitPlugin (fastify, settings, next) {
  // if whiteListInRedis is set to true, but no redis connector, then throw error.
  if (settings.whiteListInRedis && !settings.redis) {
    next('you must set redis parameter to use it')
  }

  // create the object that will hold the "main" settings that can be shared during the build
  // 'global' will define, if the rate limit should be apply by default on all route. default : true
  const globalParams = {
    global: (typeof settings.global === 'boolean') ? settings.global : true
  }

  // define the global maximum of request allowed
  globalParams.max = (typeof settings.max === 'number' || typeof settings.max === 'function')
    ? settings.max
    : 1000

  // define the global Time Window
  globalParams.globalTimeWindow = typeof settings.timeWindow === 'string'
    ? ms(settings.timeWindow)
    : typeof settings.timeWindow === 'number'
      ? settings.timeWindow
      : 1000 * 60

  // define the name of the app component. Related to redis, it will be use as a part of the keyname define in redis.
  const pluginComponent = {
    app: settings.appName || 'default'
  }

  // define the global behavior for the error;
  globalParams.skipOnError = settings.skipOnError === true

  // if we use redis then ...
  if (settings.redis) {
    // create a new redisStore connection
    pluginComponent.store = new RedisStore(settings.redis)

    // if the whitelist must be store in redis then ...
    if (settings.whiteListInRedis) {
      // add to the "global" whitelist, the "key" define in the "whitelist" object.
      pluginComponent.store.addWhiteList(`${pluginComponent.app}:wlg`, settings.whitelist || [], (err) => {
        if (err && globalParams.skipOnError === false) return next(err)
      })

      // we indicate that the plugin use redis and that the whitelist are managed in redis too. This is useful for the next step when creating the "preHandler"
      pluginComponent.isRedis = true
      pluginComponent.whiteListInRedis = true
    } else {
      // as we use redis, but we don't want to store the whitelist in redis, we define the "global" whitelist in the "pluginComponent"
      pluginComponent.whitelist = {
        global: settings.whitelist || [],
        endpoint: []
      }
      // we indicate that the plugin use redis but that the whitelist are managed locally (LRU). This is useful for the next step when creating the "preHandler"
      pluginComponent.isRedis = true
      pluginComponent.whiteListInRedis = false
    }
  } else {
    // As we don't use redis at all, we define LRU connector, we set the "global" whitelist in a object. Same for the "endpoint" whitelist that will be populated during the creation of the "preHandler"
    pluginComponent.store = new LocalStore(settings.cache)
    pluginComponent.isRedis = false
    pluginComponent.whiteListInRedis = false
    pluginComponent.whitelist = {
      global: settings.whitelist || [],
      endpoint: {}
    }
  }

  // we define the default "after" to use
  globalParams.after = ms(globalParams.globalTimeWindow, { long: true })

  globalParams.keyGenerator = typeof settings.keyGenerator === 'function'
    ? settings.keyGenerator
    : (req) => req.raw.ip

  // const makeParams = (p) => { return { ...globalParams, ...p } }

  // Function Helper to merge the parameter given in the plugin definition with the parameter given in the endpoint itself. The parameter given in the endpoint will override the default "global" parameter, such as max, timeWindow, keyGenerator,...
  const makeParams = (p) => { return Object.assign({}, globalParams, p) }

  // When a route is declare ...
  fastify.addHook('onRoute', (routeOptions) => {
    // if the plugin is set globally ( meaning that all the route will be 'rate limited' )
    if (globalParams.global) {
      // if the current endpoint have a custom rateLimit configuration ...
      if (routeOptions.config && routeOptions.config.rateLimit && typeof routeOptions.config.rateLimit === 'object') {
        // create the "preHandler" accordingly
        buildRouteRate(pluginComponent, makeParams(routeOptions.config.rateLimit), routeOptions)
      } else {
        // As the endpoint, does not have a custom rateLimit configuration, use the global one.
        buildRouteRate(pluginComponent, globalParams, routeOptions)
      }
    } else {
      // As the plugin is not applying to all routes, only the endpoint with a definition will be created.
      if (routeOptions.config && routeOptions.config.rateLimit && typeof routeOptions.config.rateLimit === 'object') {
        buildRouteRate(pluginComponent, makeParams(routeOptions.config.rateLimit), routeOptions)
      }
    }
  })
  next()
}

/**
 *
 * This function is use to generate the "preHandler" function.
 *
 * @param pluginComponent
 *  - hold the "store" connector ( LRU/REDIS ), the whitelist
 * @param params
 *  - hold the params of the current endpoint related to the rateLimit declare with config : { rateLimit : {....}}. Those were merged with the "default" settings define in the plugin. It can be : max, timeWindow, keyGenerator, ...
 * @param routeOptions
 *  - hold the "preHandler" and the "endpoint" (urlT)
 */
function buildRouteRate (pluginComponent, params, routeOptions) {
  /**
   *
   * @type {string} : is the url transformed in case the user did not give a prefixCache.
   * It will also make sure that if it's / ( root ), it will replace it with a string (root).
   * By default the '/' are replace by :
   *
   */
  const urlT = (routeOptions.url === '/') ? 'root' : routeOptions.url.replace(/\//g, ':').slice(1)

  /**
   *
   * @type {{prefix: object}} : Hold the 2 prefix used in the "key" name.
   *   - cache : prefix to use for the key relative to the 'rate limit'
   *   - wl : prefix to use for the key relative to the 'whitelist'.
   */
  const prefix = {
    cache: params.prefixCache ? params.prefixCache.replace(/[-,.;#*]/g, ':') : urlT
  }

  // We check if we are using Redis. We also check if we are using Redis for the whitelist.
  if (pluginComponent.isRedis && pluginComponent.whiteListInRedis) {
    // We set the prefix to use for the whitelist type endpoint. By default we use the URL transformed. the / are replace by :
    prefix.wl = urlT

    /**
     *
     * REDIS CASE
     * We add the whitelist of the endpoint to redis. The key will have the following format : ${pluginComponent.app}:wle:${prefix.wl}
     * pluginComponent.app is the name of the app define in the plugin with the option 'appName'.
     *
     */
    pluginComponent.store.addWhiteList(`${pluginComponent.app}:wle:${prefix.wl}`, params.whitelist, (err) => {
      if (err && params.skipOnError === false) {
        return new Error(err)
      }
    })
  } else {
    /**
     *
     * LOCAL CASE
     * As we are not using redis, store the whitelist of the current endpoint in the object 'pluginComponent.whitelist.endpoint' with the key 'prefix.cache'
     * see function rateLimitPlugin ( plugin ), we initialise the 'whitelist' object there. more information there
     *
     */
    pluginComponent.whitelist.endpoint[prefix.cache] = params.whitelist || []
  }

  /**
   *
   * PreHandler function that will be use for current endpoint been processed
   *
   * @param req
   * @param res
   * @param next
   */
  routeOptions.preHandler = (req, res, next) => {
    // We retrieve the key from the generator. ( can be the global one, or the one define in the endpoint ).
    var key = params.keyGenerator(req)

    // If we are using Redis then ...
    if (pluginComponent.isRedis) {
      // If the whitelist is manage in redis then ...
      if (pluginComponent.whiteListInRedis) {
        /**
         *
         * check if the current 'key' is member of the set of the "global" whitelist. If so, skip and go to next()
         * The set will have the following format for example for root :
         * `${pluginComponent.app}:wlg` = default:wlg
         *
         */
        pluginComponent.store.isWhiteList(`${pluginComponent.app}:wlg`, key, function ([err, result]) {
          if (err && params.skipOnError === false) return next(err)
          if (result === 1) {
            next()
          }
        })

        /**
         *
         * the 'key' was not member of the "global" whitelist, let's check in the set in the whitelist of this "endpoint" . If so, skip and go to next()
         * The set will have the following format for example for root :
         * `${pluginComponent.app}:wle:${prefix.wl}` = default:wle:root
         *
         */
        pluginComponent.store.isWhiteList(`${pluginComponent.app}:wle:${prefix.wl}`, key, function ([err, result]) {
          if (err && params.skipOnError === false) return next(err)
          if (result === 1) {
            next()
          }
        })
      }
    } else {
      /**
       *
       * As we are not using redis, check in the global whitelist and the endpoint whitelist of the plugin located in plugincomponent.whitelist.endpoint[prefix.cache]
       * If one of those condition match, then go next()
       *
       */
      if (pluginComponent.whitelist.global.indexOf(key) > -1 || pluginComponent.whitelist.endpoint[prefix.cache].indexOf(key) > -1) {
        next()
      }
    }

    // As the key is not whitelist in redis/lru, then we increment the rate-limit of the current request and we call the function "onIncr"
    pluginComponent.store.incr(prefix.cache, key, params.globalTimeWindow, onIncr)

    function onIncr (err, current) {
      if (err && params.skipOnError === false) return next(err)

      if (current <= params.max) {
        res.header('X-RateLimit-Limit', params.max)
        res.header('X-RateLimit-Remaining', params.max - current)

        if (typeof params.onExceeding === 'function') {
          params.onExceeding(req)
        }

        next()
      } else {
        if (typeof params.onExceeded === 'function') {
          params.onExceeded(req)
        }

        res.type('application/json').serializer(serializeError)
        res.code(429)
          .header('X-RateLimit-Limit', params.max)
          .header('X-RateLimit-Remaining', 0)
          .header('Retry-After', params.globalTimeWindow)
          .send({
            statusCode: 429,
            error: 'Too Many Requests',
            message: `Rate limit exceeded, retry in ${params.after}`
          })
      }
    }
  }
}

module.exports = fp(rateLimitPlugin, {
  fastify: '>=2.x',
  name: 'fastify-rate-limit'
})
