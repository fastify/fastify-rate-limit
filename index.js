'use strict'

const fp = require('fastify-plugin')
const FJS = require('fast-json-stringify')
const ms = require('ms')

const LocalStore = require('./store/LocalStore')
const RedisStore = require('./store/RedisStore')

const serializeError = FJS({
  type: 'object',
  properties: {
    statusCode: { type: 'number' },
    error: { type: 'string' },
    message: { type: 'string' }
  }
})

/**
 *
 * @param fastify
 * @param settings
 * @param next
 *
 *
 * *** settings object can have the following key :
 * - 'global'           : will tell to the plugin if all route will be set will a `rate limit`
 * - 'max'              : is the maximum number of requests a single client can perform inside a timeWindow.
 * - 'timeWindow'       : the duration of the time window, can be expressed in milliseconds (as a number) or as a string, see [`ms`](https://github.com/zeit/ms) too see the supported formats.
 * - 'cache'            : this plugin internally uses a lru cache to handle the clients, you can change the size of the cache with this option.
 * - 'whitelist'        : array of string of ips to exclude from rate limiting.
 * - 'redis'            : by default this plugins uses an in-memory store, which is fast but if you application works on more than one server it is useless, since the data is store locally.<br>
 *                        You can pass a Redis client here and magically the issue is solved. To achieve the maximum speed, this plugins requires the use of [`ioredis`](https://github.com/luin/ioredis).
 * - 'skipOnError'      : if `true` it will skip errors generated by the storage (eg, redis not reachable).
 * - 'keyGenerator'     : a function to generate a unique identifier for each incoming request. Defaults to `(req) => req.ip`, the IP is resolved by fastify using `req.connection.remoteAddress` or `req.headers['x-forwarded-for']` if [trustProxy](https://www.fastify.io/docs/master/Server/#trustproxy) option is enabled. Use it if you want to override this behavior. Example usage:
 *
 *
 */

function rateLimitPlugin (fastify, settings, next) {
  // create the object that will hold the "main" settings that can be shared during the build
  // 'global' will define, if the rate limit should be apply by default on all route. default : true
  const globalParams = {
    global: (typeof settings.global === 'boolean') ? settings.global : true
  }

  // define the global maximum of request allowed
  globalParams.max = (typeof settings.max === 'number' || typeof settings.max === 'function')
    ? settings.max
    : 1000

  // define the global Time Window
  globalParams.timeWindow = typeof settings.timeWindow === 'string'
    ? ms(settings.timeWindow)
    : typeof settings.timeWindow === 'number'
      ? settings.timeWindow
      : 1000 * 60

  globalParams.whitelist = settings.whitelist || []

  // define the name of the app component. Related to redis, it will be use as a part of the keyname define in redis.
  const pluginComponent = {
    whitelist: globalParams.whitelist
  }

  if (settings.redis) {
    pluginComponent.store = new RedisStore(settings.redis, 'fastify-rate-limit-', globalParams.timeWindow)
  } else {
    pluginComponent.store = new LocalStore(globalParams.timeWindow, settings.cache, fastify)
  }

  globalParams.keyGenerator = typeof settings.keyGenerator === 'function'
    ? settings.keyGenerator
    : (req) => req.raw.ip

  // Function Helper to merge the parameter given in the plugin definition with the parameter given in the endpoint itself. The parameter given in the endpoint will override the default "global" parameter, such as max, timeWindow, keyGenerator,...
  const makeParams = (p) => {
    const result = Object.assign({}, globalParams, p)
    if (typeof result.timeWindow === 'string') {
      result.timeWindow = ms(result.timeWindow)
    }
    return result
  }

  // When a route is declare ...
  fastify.addHook('onRoute', (routeOptions) => {
    if (routeOptions.config) {
      if (routeOptions.config.rateLimit && typeof routeOptions.config.rateLimit === 'object') {
        const current = Object.create(pluginComponent)
        current.store = pluginComponent.store.child(routeOptions)
        // if the current endpoint have a custom rateLimit configuration ...
        buildRouteRate(current, makeParams(routeOptions.config.rateLimit), routeOptions)
      } else if (routeOptions.config.rateLimit === false) {
        // nothing to do
      } else {
        throw new Error('Unknownv value for rateLimit configuration')
      }
    } else if (globalParams.global) {
      // if the plugin is set globally ( meaning that all the route will be 'rate limited' )
      // As the endpoint, does not have a custom rateLimit configuration, use the global one.
      buildRouteRate(pluginComponent, globalParams, routeOptions)
    }
  })
  next()
}

/**
 *
 * This function is use to generate the "preHandler" function.
 *
 * @param pluginComponent
 *  - hold the "store" connector ( LRU/REDIS ), the whitelist
 * @param params
 *  - hold the params of the current endpoint related to the rateLimit declare with config : { rateLimit : {....}}. Those were merged with the "default" settings define in the plugin. It can be : max, timeWindow, keyGenerator, ...
 * @param routeOptions
 *  - hold the "preHandler" and the "endpoint" (urlT)
 */
function buildRouteRate (pluginComponent, params, routeOptions) {
  const after = ms(params.timeWindow, { long: true })

  /**
   *
   * PreHandler function that will be use for current endpoint been processed
   *
   * @param req
   * @param res
   * @param next
   */
  const preHandler = (req, res, next) => {
    // We retrieve the key from the generator. ( can be the global one, or the one define in the endpoint ).
    var key = params.keyGenerator(req)

    /**
     *
     * check in the global whitelist.
     * If one of those condition match, then go next()
     *
     */
    if (pluginComponent.whitelist.indexOf(key) > -1) {
      next()
      return
    }

    // As the key is not whitelist in redis/lru, then we increment the rate-limit of the current request and we call the function "onIncr"
    pluginComponent.store.incr(key, onIncr)

    function onIncr (err, current) {
      if (err && params.skipOnError === false) return next(err)

      if (current <= params.max) {
        res.header('X-RateLimit-Limit', params.max)
        res.header('X-RateLimit-Remaining', params.max - current)

        if (typeof params.onExceeding === 'function') {
          params.onExceeding(req)
        }

        next()
      } else {
        if (typeof params.onExceeded === 'function') {
          params.onExceeded(req)
        }

        res.type('application/json').serializer(serializeError)
        res.code(429)
          .header('X-RateLimit-Limit', params.max)
          .header('X-RateLimit-Remaining', 0)
          .header('Retry-After', params.timeWindow)
          .send({
            statusCode: 429,
            error: 'Too Many Requests',
            message: `Rate limit exceeded, retry in ${after}`
          })
      }
    }
  }

  if (Array.isArray(routeOptions.preHandler)) {
    routeOptions.preHandler.push(preHandler)
  } else if (typeof routeOptions.preHandler === 'function') {
    routeOptions.preHandler = [routeOptions.preHandler, preHandler]
  } else {
    routeOptions.preHandler = [preHandler]
  }
}

module.exports = fp(rateLimitPlugin, {
  fastify: '>=2.x',
  name: 'fastify-rate-limit'
})
